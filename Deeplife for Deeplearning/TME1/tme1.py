# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_na46C76y9mgAkB4Y2s4Zp6bGA3BUkMs
"""

#TME 1 Deeplife : Final Draft Cell
#Gabriel PELLE : 21400641
#Spencer GOLDSTEIN : 21401714
#Maher TANTOUCH : 21219364



import torch
import matplotlib.pyplot as plt
import torchvision.transforms as transforms
from torch import nn
from torch.utils.data import DataLoader
from torchvision import datasets
from torchvision.transforms import ToTensor
import torchvision
from torchview import draw_graph
import numpy as np
import os


# q1:

def question1():
    '''
    Imprimer votre réponse
    Afficher l'image sous la forme d'une image
    '''
    print("q1 : ")
    try:
      raw = os.path.join("/content/gdrive/MyDrive/Sorbonne/M1_Personal/Deeplife/TME1/data/raw")
      dataset = datasets.MNIST(root=raw, train=True)

      img,label = dataset[0]

      print("shape of one image sample (pixels):", img.size)
      print("Number of samples in the dataset", len(dataset))

      img = dataset[0][0]
      plt.imshow(img, cmap='gray');

      print("The dimensions of a image sample correspond to the image")
    except Exception as e:
      print("Error in file path : Please reset")
      print("Code Q1 : \n")
      print("raw = os.path.join(/content/gdrive/MyDrive/Sorbonne/M1_Personal/Deeplife/TME1/data/raw \n")
      print("dataset = datasets.MNIST(root=raw, train=True) \n")
      print("img,label = dataset[0] \n")
      print("print(shape of one image sample (pixels):, img.size) \n")
      print(" print(Number of samples in the dataset, len(dataset)) \n")
      print("img = dataset[0][0] \n")
      print("plt.imshow(img, cmap='gray'); \n")
      print("print(The dimensions of a image sample correspond to the image) \n")

    return None




# q2:

def question2():
    '''
    Sortie:
    T : le tenseur de la forme [1,3,3,3] ne contenant que des 1.
    T1: la multiplication sur la dernière dimension du premier tenseur et la dernière dimension du deuxième
    T2: la multiplication dela deuxieme dimension du premier et la troisieme dimension du deuxieme tenseur
    Y: 3 copies de T stack les unes sur les autres
    Z: Y sous la forme d'un matrice  [9,9]

    '''
    shape = (1,3,3,3)
    T = torch.ones(shape)
    T1 = torch.tensordot(T, T, dims=([-1], [-1]))
    T2 = torch.tensordot(T, T, dims=([1], [2]))
    Y = torch.stack((T,T,T), dim = 0)
    Z = torch.reshape(Y, (9,9))
    print("q2 : ")
    print("T:", T)
    print("T1:", T1)
    print("T2:", T2)
    print("Y:", Y)
    print("Z:", Z)
    return None


# q3:
def question3(training_data):
    '''
    Imprimez vos réponses en précisant dans votre code (ou en faisant appel) les fonctions qui vous ont permis de trouver ces réponses
    '''
    print("Number of samples in the dataset (len(training_data))", len(training_data))
    labels = training_data.targets.unique()
    print("Number of Classes (len(training_data.targets.unique()):" , len(labels))
    print("Classes (training_data.targets.unique()):", labels)
    return None


# q4:

def question4(training_data):
    '''
    Entrée: training_data le jeu de donnée train de Mnist
    Sortie:
    mnist_small_torch: le jeu de donné qui on comme label la deuxième classe qui est affichée par training_data.class_to_idx
    '''
    labels = training_data.class_to_idx
    keys = list(labels)
    second_class = labels[keys[1]]

    second_class_mask = training_data.targets == second_class


    mnist_small_torch = torch.utils.data.Subset(training_data, second_class_mask.nonzero().squeeze())
    print("q4 : ")
    print("Number of data in second class:", len(mnist_small_torch))
    print("This seems coherent as its about 1/10th of the dataset, and the training data should be fairly balanced across classes")


    return mnist_small_torch

# q5:

def decoupage(training_data, test_data):
    train_images = []
    train_labels = []

    for img, label in training_data:
        if label == 7 or label == 9:
            train_images.append(img)
            train_labels.append(0 if label == 7 else 1)

    test_images = []
    test_labels = []

    for img, label in test_data:
        if label == 7 or label == 9:
            test_images.append(img)
            test_labels.append(0 if label == 7 else 1)

    train_images_tensor = torch.stack(train_images)
    train_labels_tensor = torch.tensor(train_labels)

    test_images_tensor = torch.stack(test_images)
    test_labels_tensor = torch.tensor(test_labels)

    restrict_train = torch.utils.data.TensorDataset(train_images_tensor, train_labels_tensor)
    restrict_test = torch.utils.data.TensorDataset(test_images_tensor, test_labels_tensor)

    print("Q5:")
    print("Train dataset size:", len(restrict_train))
    print("Test dataset size:", len(restrict_test))

    return restrict_train, restrict_test


#q6
def Normalize_dataset(dataset):
    '''
    Entrée:
    Le jeu de donnée de tenseurs, c'est à dire un tenseur de taille 4
    la première dimension correspond au nombre d'element dans le jeu de donnée
    le second le nombre de couleurs/channel de l'image  (ici 1 les images sont en noir et blanc)
    le troisième et quatrième la longeur et largeur de l'image

    Sortie:
    Le jeu de donnée normalisée sous la forme d'un tenseur de taille 4
    '''
    mean = dataset.mean([0, 2, 3])
    std = dataset.std([0, 2, 3])

    normalize = transforms.Normalize(mean, std)
    Normalized = torch.stack([normalize(image) for image in dataset])

    print("Q6: Dataset normalized.")

    return Normalized


#q7

def RandomCrop_dataset(dataset):
    '''
    Entrée:
    Le jeu de donnée de tenseurs, c'est à dire un tenseur de taille 4
    la première dimension correspond au nombre d'element dans le jeu de donnée
    le second le nombre de couleurs/channel de l'image  (ici 1 les images sont en noir et blanc)
    le troisième et quatrième la longeur et largeur de l'image

    Sortie:
    Le jeu de donnée apres application de RandomCrop_dataset sous la forme d'un tenseur de taille 4
    '''
    print('RandomCrop randomly selects a portion of given size of the image and crops it.\n')
    print('This adds variablilty to the data and forces the model to focus on other underlying patterns. \n')
    print('This can also avoid overfitting to the training data. \n')

    crop_size = (20,20)
    random_crop = transforms.RandomCrop(crop_size)

    Cropped = torch.stack([random_crop(image) for image in dataset])
    plt.imshow(Cropped[0,0])
    print("Q7: Random cropping applied.")

    return Cropped


#q8

def Choix_transformation(dataset):
    '''
    Réponse ce que fait la fonction : Cette opération transforme de manière aléatoire une image en couleur en une image en niveaux de gris, avec
    une probabilité définie (par défaut fixée à 0.1) -> peut être bénéfique pour améliorer la solidité du modèle en l'exerçant à acquérir
    des représentations indépendamment des couleurs exclusivement.
    '''

    print("q8 : Cette opération transforme de manière aléatoire une image en couleur en une image en niveaux de gris, avec une probabilité définie (par défaut fixée à 0.1) -> peut être bénéfique pour améliorer la solidité du modèle en l'exerçant à acquérir des représentations indépendamment des couleurs exclusivement.")

    random_grayscale = transforms.RandomGrayscale(p=0.5)

    Choix = torch.stack([random_grayscale(image) for image in dataset])
    plt.imshow(Choix[0, 0])
    return Choix


#q9

class Twolayers(torch.nn.Module):

    def __init__(self,ninput,noutput):
        super(Twolayers, self).__init__()

        self.linear1 = torch.nn.Linear(ninput, 200)
        self.activation = torch.nn.ReLU()
        self.linear2 = torch.nn.Linear(200, noutput)
        self.softmax = torch.nn.Softmax()

    def forward(self, input):
        input = input.view(input.size(0), -1)
        x = self.linear1(input)
        x = self.activation(x)
        x = self.linear2(x)
        output = self.softmax(x)
        return output


def main():
  training_data = datasets.MNIST(root="data", train=True, download=True, transform=ToTensor())
  test_data = datasets.MNIST(root="data", train=False, download=True, transform=ToTensor())

  question1()
  question2()
  question3(training_data)

  mnist_small_torch = question4(training_data)
  #q5
  restrict_train, restrict_test = decoupage(training_data, test_data)
  restrict_train_tensors = torch.stack([restrict_train[i][0] for i in range(len(restrict_train))])
  #q6/7
  Normalized_train = Normalize_dataset(restrict_train_tensors)
  print(f"Mean of normalized dataset: {Normalized_train.mean([0, 2, 3])}")
  print(f"Standard deviation of normalized dataset: {Normalized_train.std([0, 2, 3])}")

  Cropped_train = RandomCrop_dataset(restrict_train_tensors)

  ##q8
  Choix = Choix_transformation(restrict_train_tensors)

  ##q9
  ninput = 28*28
  noutput = 2
  print("ninput = 28*28")
  print("noutput = 2")
  twolayers = Twolayers(ninput, noutput)
  model_graph = draw_graph(twolayers, input_size=(1, 1, 28, 28), expand_nested=True)
  model_graph.visual_graph
  print("Q9: Model graph visualization generated.")

if __name__ == "__main__":
    main()

